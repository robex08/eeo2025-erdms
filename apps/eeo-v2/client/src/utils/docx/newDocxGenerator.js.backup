/**
 * NOV√ù DOCX GENER√ÅTOR - Kompletn√≠ ≈ôe≈°en√≠ pro generov√°n√≠ DOCX dokument≈Ø
 * 
 * POSTUP:
     // === KROK 4: Naƒçten√≠ dat z POST /api.eeo/sablona_docx/order-data ===
    console.log('üîå KROK 4: Naƒç√≠t√°m data z POST /api.eeo/sablona_docx/order-data...');
    let orderApiData;
    
    try {
      const apiResponse = await getDocxOrderData({
        token,
        username,
        objednavka_id: orderId
      });
      
      if (!apiResponse || !apiResponse.data) {
        throw new Error('API nevr√°tilo data');
      }
      
      orderApiData = apiResponse.data;
      
      console.log('‚úÖ POST /api.eeo/sablona_docx/order-data √∫spƒõ≈°n√©');
      
      // üîç DEBUG - Surov√° data z datab√°ze
      console.log('üîç DEBUG - Surov√° data z datab√°ze:', {
        endpoint: 'POST /api.eeo/sablona_docx/order-data',
        responseStatus: apiResponse.status,
        dataKeys: Object.keys(orderApiData),
        osnovniPole: {
          cislo_objednavky: orderApiData.cislo_objednavky,
          nazev_objednavky: orderApiData.nazev_objednavky,
          predmet: orderApiData.predmet,
          datum_objednavky: orderApiData.datum_objednavky,
          celkova_cena_s_dph: orderApiData.celkova_cena_s_dph
        },
        vnoreneObjekty: {
          objednatel: orderApiData.objednatel ? {
            jmeno: orderApiData.objednatel.jmeno,
            prijmeni: orderApiData.objednatel.prijmeni,
            plne_jmeno: orderApiData.objednatel.plne_jmeno,
            email: orderApiData.objednatel.email
          } : 'NEEXISTUJE',
          dodavatel: orderApiData.dodavatel ? {
            nazev: orderApiData.dodavatel.nazev,
            adresa: orderApiData.dodavatel.adresa,
            ico: orderApiData.dodavatel.ico
          } : 'NEEXISTUJE',
          stav: orderApiData.stav ? {
            nazev: orderApiData.stav.nazev,
            popis: orderApiData.stav.popis
          } : 'NEEXISTUJE'
        },
        polozkyArilogy: {
          polozky_count: orderApiData.polozky?.length || 0,
          prilohy_count: orderApiData.prilohy?.length || 0,
          prvni_polozka: orderApiData.polozky?.[0] || '≈Ω√ÅDN√â',
          prvni_priloha: orderApiData.prilohy?.[0] || '≈Ω√ÅDN√â'
        }
      });
      
    } catch (apiError) {
      console.error('‚ùå POST /api.eeo/sablona_docx/order-data selhalo:', apiError);
      throw new Error(`Nepoda≈ôilo se naƒç√≠st data z API: ${apiError.message}`);
    }≈°ablony ze serveru
 * 2. Rozbalen√≠ ZIP struktury
 * 3. Pou≈æit√≠ JSON mapov√°n√≠ ulo≈æen√©ho u ≈°ablony
 * 4. Naplnƒõn√≠ XML pomoc√≠ algoritm≈Ø z n√°hledu
 * 5. Naƒçten√≠ dat z POST /api.eeo/sablona_docx/order-data
 * 6. Zabalen√≠ upraven√©ho XML a sta≈æen√≠ DOCX
 * 
 * @date 2025-10-22
 */

import JSZip from 'jszip';
import { getDocxOrderData } from '../../services/apiDocxOrders';
import { downloadDocxSablonaAsFile, getDocxSablonaDetail } from '../../services/apiv2Dictionaries';
import { getOrder25 } from '../../services/api25orders'; // Pro fallback

/**
 * Hlavn√≠ funkce pro generov√°n√≠ DOCX dokumentu podle nov√©ho postupu
 * @param {Object} params - Parametry generov√°n√≠
 * @param {string} params.templateId - ID ≈°ablony
 * @param {string} params.orderId - ID objedn√°vky
 * @param {string} params.token - Autentizaƒçn√≠ token
 * @param {string} params.username - Username u≈æivatele
 * @param {Object} params.template - Objekt ≈°ablony s JSON mapov√°n√≠m
 * @returns {Promise<Blob>} - Vygenerovan√Ω DOCX soubor
 */
export async function generateDocxDocument({
  templateId,
  orderId,
  token,
  username,
  template
}) {
  try {
    console.log('üöÄ NOV√ù DOCX GENER√ÅTOR - Zaƒç√°tek procesu:', {
      templateId,
      orderId,
      templateName: template?.nazev
    });

    // === KROK 0 üìä NAƒåTEN√ç DETAILU ≈†ABLONY Z DATAB√ÅZE ===
    console.log('%c[KROK 0 üìä] NAƒå√çT√ÅN√ç DETAILU ≈†ABLONY Z DATAB√ÅZE', 'background: #fef3c7; color: #d97706; font-weight: bold; padding: 4px 8px;');
    
    const templateDetail = await getDocxSablonaDetail({
      token,
      username,
      id: templateId
    });
    
    if (!templateDetail || !templateDetail.data) {
      throw new Error('Nepoda≈ôilo se naƒç√≠st detail ≈°ablony z datab√°ze');
    }
    
    const templateData = templateDetail.data;
    console.log('üîç DEBUG - Detail ≈°ablony z DB:', {
      id: templateData.id,
      nazev: templateData.nazev,
      hasMapovanJson: !!templateData.mapovan_json,
      mapovanJsonLength: templateData.mapovan_json?.length || 0,
      mapovanJsonPreview: templateData.mapovan_json?.substring(0, 100) + '...' || '≈æ√°dn√©'
    });
    
    console.log('‚úÖ KROK 0 dokonƒçen - detail ≈°ablony naƒçten');

    // === KROK 1 üìÅ NAƒåTEN√ç DOCX ≈†ABLONY ZE SERVERU ===
    console.log('%c[KROK 1 üìÅ] NAƒå√çT√ÅN√ç DOCX ≈†ABLONY ZE SERVERU', 'background: #dbeafe; color: #1d4ed8; font-weight: bold; padding: 4px 8px;');
    const templateFile = await downloadDocxSablonaAsFile({
      token,
      username,
      id: templateId,
      fileName: template.nazev || 'template.docx'
    });
    
    console.log('‚úÖ ≈†ablona naƒçtena:', {
      fileName: templateFile.name,
      size: templateFile.size
    });

    // === KROK 2: Rozbalen√≠ ZIP struktury ===
    console.log('üì¶ KROK 2: Rozbaluji ZIP strukturu DOCX...');
    const zip = new JSZip();
    const loadedZip = await zip.loadAsync(templateFile);
    
    // Naƒçti document.xml
    const documentXml = await loadedZip.file('word/document.xml')?.async('text');
    if (!documentXml) {
      throw new Error('Neplatn√° DOCX ≈°ablona - chyb√≠ document.xml');
    }
    
    console.log('‚úÖ ZIP struktura rozbalena:', {
      documentXmlLength: documentXml.length,
      filesInZip: Object.keys(loadedZip.files).length
    });

    // === KROK 3 üóÇÔ∏è NAƒåTEN√ç DYNAMICK√âHO MAPOV√ÅN√ç Z DATAB√ÅZE ===
    console.log('%c[KROK 3 üóÇÔ∏è] NAƒå√çT√ÅN√ç DYNAMICK√âHO MAPOV√ÅN√ç Z DATAB√ÅZE', 'background: #f3e8ff; color: #7c3aed; font-weight: bold; padding: 4px 8px;');
    
    let templateMapping = {};
    
    if (templateData.mapovan_json) {
      try {
        templateMapping = typeof templateData.mapovan_json === 'string' 
          ? JSON.parse(templateData.mapovan_json) 
          : templateData.mapovan_json;
        
        console.log('üîç DEBUG - Mapov√°n√≠ naƒçteno z DB (mapovan_json):', {
          raw: templateData.mapovan_json,
          parsed: templateMapping,
          fieldsCount: Object.keys(templateMapping).length,
          sampleMapping: Object.entries(templateMapping).slice(0, 3).map(([docxField, dbField]) => `${docxField} ‚Üê ${dbField}`)
        });
        
        console.log('‚úÖ KROK 3 dokonƒçen - dynamick√© mapov√°n√≠ z DB naƒçteno:', Object.keys(templateMapping).length, 'pol√≠');
      } catch (error) {
        console.error('‚ùå Chyba p≈ôi parsov√°n√≠ mapovan_json:', error);
        throw new Error(`Neplatn√© JSON mapov√°n√≠ v ≈°ablonƒõ: ${error.message}`);
      }
    } else {
      console.warn('‚ö†Ô∏è POZOR: ≈†ablona nem√° definovan√© mapov√°n_json!');
      throw new Error('≈†ablona nem√° definovan√© mapov√°n√≠ pol√≠ (mapovan_json). Nejd≈ô√≠ve upravte ≈°ablonu a definujte mapov√°n√≠.');
    }

    // === KROK 4: Naƒçten√≠ dat z API ===
    console.log('üîå KROK 4: Naƒç√≠t√°m data z POST /api.eeo/sablona_docx/order-data...');
    const orderApiData = await getDocxOrderData({
      token,
      username,
      objednavka_id: orderId  // Pou≈æij spr√°vn√Ω parametr
    });
    
    if (!orderApiData || !orderApiData.data) {
      throw new Error('Nepoda≈ôilo se naƒç√≠st data objedn√°vky z API');
    }
    
    console.log('‚úÖ API data naƒçtena:', {
      cislo_objednavky: orderApiData.data?.cislo_objednavky,
      objednatel: !!orderApiData.data?.objednatel,
      dodavatel: !!orderApiData.data?.dodavatel,
      polozkyCount: orderApiData.data?.polozky?.length || 0
    });

    // === KROK 5: Mapov√°n√≠ podle DOCX ≈°ablon (stejnƒõ jako HTML) ===
    console.log('üîÑ KROK 5: Mapuji data podle DOCX ≈°ablony - stejnƒõ jako pro HTML...');
    const mappedFieldValues = createFieldMappingForDocx(orderApiData, templateMapping);
    
    console.log('üîç DEBUG - Mapov√°n√≠ dokonƒçeno:', {
      pocetPol√≠: Object.keys(mappedFieldValues).length,
      vzorkaMapovan√≠: Object.entries(mappedFieldValues).slice(0, 15).reduce((acc, [key, value]) => {
        acc[key] = value;
        return acc;
      }, {}),
      legacyPole: {
        'EVIDENCNI_CISLO': mappedFieldValues['EVIDENCNI_CISLO'],
        'predmet': mappedFieldValues['predmet'],
        'DNAZEV': mappedFieldValues['DNAZEV'],
        'OJMENO': mappedFieldValues['OJMENO'],
        'CENA': mappedFieldValues['CENA']
      }
    });

    // === KROK 6: Naplnƒõn√≠ XML pomoc√≠ algoritm≈Ø z n√°hledu ===
    console.log('üìù KROK 6: Napl≈àuji XML pomoc√≠ algoritm≈Ø z n√°hledu...');
    const filledXml = fillXmlWithFieldData(documentXml, mappedFieldValues);
    
    console.log('‚úÖ XML naplnƒõno daty:', {
      originalLength: documentXml.length,
      filledLength: filledXml.length,
      sizeDifference: filledXml.length - documentXml.length
    });

    // === KROK 7: Zabalen√≠ upraven√©ho XML a p≈ô√≠prava ke sta≈æen√≠ ===
    console.log('üì¶ KROK 7: Zabaluji upraven√© XML zpƒõt do DOCX...');
    loadedZip.file('word/document.xml', filledXml);
    const generatedDocx = await loadedZip.generateAsync({ type: 'blob' });
    
    console.log('‚úÖ DOCX dokument vygenerov√°n:', {
      originalSize: templateFile.size,
      generatedSize: generatedDocx.size,
      fileName: `objednavka_${orderApiData.data?.cislo_objednavky}_${template.nazev}.docx`
    });

    return generatedDocx;

  } catch (error) {
    console.error('‚ùå Chyba p≈ôi generov√°n√≠ DOCX dokumentu:', error);
    throw error;
  }
}

/**
 * DYNAMICK√â MAPOV√ÅN√ç POL√ç - podle JSON definice ze ≈°ablony (mapovan_json)
 * ≈Ω√ÅDN√â HARDCODED MAPOV√ÅN√ç! V≈°e se mapuje podle definice v datab√°zi
 * @param {Object} apiData - Data z POST /api.eeo/sablona_docx/order-data
 * @param {Object} templateMapping - JSON mapov√°n√≠ ze ≈°ablony (mapovan_json)
 * @returns {Object} - Namapovan√° pole pro DOCX
 */
function createFieldMappingForDocx(apiData, templateMapping) {
  console.log('üîç DEBUG - Zaƒç√≠n√°m DYNAMICK√â mapov√°n√≠ podle ≈°ablony:');
  console.log('üîç DEBUG - Template mapping:', templateMapping);
  console.log('üîç DEBUG - API data kl√≠ƒçe:', Object.keys(apiData));
  
  const mappedData = {};
  
  // PROCH√ÅZ√çME MAPOV√ÅN√ç ZE ≈†ABLONY - ka≈æd√© pole mapujeme podle definice
  Object.entries(templateMapping).forEach(([docxField, dbPath]) => {
  mappedData['cislo_objednavky'] = apiData.cislo_objednavky || '';
  mappedData['datum_objednavky'] = apiData.datum_objednavky || '';
  mappedData['nazev_objednavky'] = apiData.nazev_objednavky || '';
  mappedData['predmet'] = apiData.predmet || '';
  mappedData['popis'] = apiData.popis || '';
  mappedData['poznamka'] = apiData.poznamka || '';
  mappedData['max_cena_s_dph'] = apiData.max_cena_s_dph || '';
  mappedData['misto_dodani'] = apiData.misto_dodani || '';
  mappedData['celkova_cena_s_dph'] = apiData.celkova_cena_s_dph || '';
  
  // === OBJEDNATEL (vno≈ôen√Ω objekt) ===
  if (apiData.objednatel) {
    const objednatel = apiData.objednatel;
    mappedData['objednatel.jmeno'] = objednatel.jmeno || '';
    mappedData['objednatel.prijmeni'] = objednatel.prijmeni || '';
    mappedData['objednatel.email'] = objednatel.email || '';
    mappedData['objednatel.telefon'] = objednatel.telefon || '';
    mappedData['objednatel.plne_jmeno'] = objednatel.plne_jmeno || `${objednatel.jmeno || ''} ${objednatel.prijmeni || ''}`.trim();
    
    console.log('üîç DEBUG - Objednatel mapov√°n:', {
      'objednatel.jmeno': mappedData['objednatel.jmeno'],
      'objednatel.prijmeni': mappedData['objednatel.prijmeni'], 
      'objednatel.plne_jmeno': mappedData['objednatel.plne_jmeno']
    });
  }
  
  // === DODAVATEL (vno≈ôen√Ω objekt) ===
  if (apiData.dodavatel) {
    const dodavatel = apiData.dodavatel;
    mappedData['dodavatel.nazev'] = dodavatel.nazev || '';
    mappedData['dodavatel.adresa'] = dodavatel.adresa || '';
    mappedData['dodavatel.ico'] = dodavatel.ico || '';
    mappedData['dodavatel.dic'] = dodavatel.dic || '';
    
    console.log('üîç DEBUG - Dodavatel mapov√°n:', {
      'dodavatel.nazev': mappedData['dodavatel.nazev'],
      'dodavatel.adresa': mappedData['dodavatel.adresa'],
      'dodavatel.ico': mappedData['dodavatel.ico']
    });
  }
  
  // === STAV ===
  if (apiData.stav) {
    mappedData['stav.nazev'] = apiData.stav.nazev || '';
    mappedData['stav.popis'] = apiData.stav.popis || '';
  }
  
  // === LEGACY MAPOV√ÅN√ç PRO STAR≈†√ç ≈†ABLONY (UPPERCASE n√°zvy) ===
  // STEJN√â JAKO V docxProcessor.js - mapOrderToDocxFields
  
  // EVIDENCNI_CISLO - ƒç√≠slo objedn√°vky
  mappedData['EVIDENCNI_CISLO'] = mappedData['cislo_objednavky'];
  
  // Dodavatel - D* prefix
  mappedData['DNAZEV'] = mappedData['dodavatel.nazev'];
  mappedData['DADRESA'] = mappedData['dodavatel.adresa'];
  mappedData['DICO'] = mappedData['dodavatel.ico'];
  mappedData['DDIC'] = mappedData['dodavatel.dic'];
  
  // Objednatel - O* prefix  
  mappedData['OJMENO'] = mappedData['objednatel.plne_jmeno'];
  mappedData['OEMAIL'] = mappedData['objednatel.email'];
  mappedData['OTELEFON'] = mappedData['objednatel.telefon'];
  
  // Ceny
  mappedData['CENA'] = mappedData['max_cena_s_dph'] || mappedData['celkova_cena_s_dph'];
  mappedData['DATUM'] = mappedData['datum_objednavky'];
  
  console.log('ÔøΩ DEBUG - Legacy pole namapov√°na:', {
    'EVIDENCNI_CISLO': mappedData['EVIDENCNI_CISLO'],
    'DNAZEV': mappedData['DNAZEV'],
    'OJMENO': mappedData['OJMENO'],
    'CENA': mappedData['CENA'],
    'predmet': mappedData['predmet']
  });
  
  return mappedData;
}

/**
 * Napln√≠ XML data pomoc√≠ algoritm≈Ø z n√°hledu (stejn√Ω princip jako v previewDocxFields)
 * @param {string} xmlContent - P≈Øvodn√≠ XML obsah
 * @param {Object} fieldValues - Mapovan√© hodnoty pol√≠
 * @returns {string} - XML s vyplnƒõn√Ωmi daty
 */
function fillXmlWithFieldData(xmlContent, fieldValues) {
  let filledXml = xmlContent;
  let replacementCount = 0;
  
  console.log('üîç Zaƒç√≠n√°m napl≈àov√°n√≠ XML pol√≠...');
  console.log('üìã Dostupn√° pole:', Object.keys(fieldValues).slice(0, 10));
  
  // === ALGORITMUS 1: Nahrazen√≠ {FIELD_NAME} vzor≈Ø ===
  Object.entries(fieldValues).forEach(([fieldName, value]) => {
    const placeholder = `{${fieldName.toUpperCase()}}`;
    const regex = new RegExp(escapeRegExp(placeholder), 'g');
    const beforeLength = filledXml.length;
    filledXml = filledXml.replace(regex, String(value || ''));
    
    if (filledXml.length !== beforeLength) {
      replacementCount++;
      console.log(`‚úÖ Nahrazeno ${placeholder} ‚Üí "${value}"`);
    }
  });
  
  // === ALGORITMUS 2: Nahrazen√≠ DOCVARIABLE vzor≈Ø ===
  Object.entries(fieldValues).forEach(([fieldName, value]) => {
    // Pattern pro DOCVARIABLE (pou≈æ√≠v√° se v ≈°ablon√°ch)
    const patterns = [
      `DOCVARIABLE\\s+${escapeRegExp(fieldName)}`,
      `\\{\\s*DOCVARIABLE\\s+${escapeRegExp(fieldName)}\\s*\\}`,
      `\\|DOCX\\.${escapeRegExp(fieldName)}`
    ];
    
    patterns.forEach(pattern => {
      const regex = new RegExp(pattern, 'gi');
      const beforeLength = filledXml.length;
      filledXml = filledXml.replace(regex, String(value || ''));
      
      if (filledXml.length !== beforeLength) {
        replacementCount++;
        console.log(`‚úÖ Nahrazeno DOCVARIABLE ${fieldName} ‚Üí "${value}"`);
      }
    });
  });
  
  console.log(`‚úÖ XML naplnƒõn√≠ dokonƒçeno - ${replacementCount} nahrazen√≠`);
  return filledXml;
}

/**
 * Escape speci√°ln√≠ch znak≈Ø pro regex
 * @param {string} string - ≈òetƒõzec k escape
 * @returns {string} - Escapovan√Ω ≈ôetƒõzec
 */
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * St√°hne vygenerovan√Ω DOCX soubor
 * @param {Blob} docxBlob - DOCX blob
 * @param {string} fileName - N√°zev souboru
 */
export function downloadGeneratedDocx(docxBlob, fileName) {
  const url = URL.createObjectURL(docxBlob);
  const link = document.createElement('a');
  link.href = url;
  link.download = fileName;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
  
  console.log('üì• DOCX soubor sta≈æen:', fileName);
}